const startBtn = document.querySelector("#start"); //забираем кнопку 'начать'
const screens = document.querySelectorAll(".screen"); //забираем все экраны
const timeList = document.querySelector("#time-list"); //забираем все кнопки выбора времени (10,20,30 секунд)
const timeEl = document.querySelector("#time"); //забираем будущий таймер времени игры в переменную
const board = document.querySelector("#board"); //забираем пустой див в перменную, т.к. скоро там будут появляться кружочки)
const colors = [
  "red",
  "orange",
  "green",
  "yellow",
  "blue",
  "#1164B4",
  "purple",
]; // забираем цвета, которыми должны гореть кружки

let time = 0; //создаем переменную времени (по умолчанию ставим 0), благодоря ей мы потом будем устанавливать 10,20,30 секунд
let score = 0; //панель результата кружков

startBtn.addEventListener("click", (event) => {
  event.preventDefault(); //В HTML стоит заглушка a href #, при помощи этой функции, мы просто отменем поведение по умолчанию

  screens[0].classList.add("up"); //скрин - это массив, (все начинается с нуля ) и пишем ему, добавь этому массиву класс up, потому что в стилях screen up = -100vh
});

timeList.addEventListener("click", (event) => {
  //при клике на все 3 кнопки делаем проверку
  if (event.target.classList.contains("time-btn")) {
    console.log(event.target.getAttribute("data-time")); //если у наших элементов имеют класс time-btn, тогда для начала их проверим в консоли сначала без getA (И тогда будут выводиться все кнопки при нажатии по отдельности). Потом в HTML добавляем дата таймы и делаем проверку в консоли c getA и получаем цифры каждой кнопки 10,20,30

    time = parseInt(event.target.getAttribute("data-time")); //теперь мы должны превратить строки 10,20,30 в цифры при помощи ф-ции parseInt() либо ставим + вначало и сохраняем это все в переменную time

    // console.log(time); //выводим в консоль time и должны опять получить 10,20 ,30 НО уже в цифрах!

    screens[1].classList.add("up"); //т.к. мы работаем на втором экране, мы добавляем класс up, потому что в стилях screen up = -100vh

    startGame(); //прописываем ф-цию, нажав на любую кнопку нас будет перебрасывать на само поле игры
  }
});

board.addEventListener("click", (event) => {
  if (event.target.classList.contains("circle")) {
    score++; //тогда увеличиваем панель результата на 1 единицу
    event.target.remove(); //удаляем отображение кружока при клике
    crateRandomCircle(); //заного воспроизводим отображение нового кружка в новом месте
  }
}); //спрашиваем, если в нашем пустом диве происходит клик, этот клик идет на область с объекта с классом "Циркуль" (Кружок), тогда:

function startGame() {
  setInterval(decreaseTime, 1000); //делаем таймер живим при помощи сет интервал и передаем ей функцию, которая будет выполнятся ровно каждую секунду (1000 миллисекунд)

  crateRandomCircle(); //запускаем наши кружочки!)

  timeEl.innerHTML = `00:${time}`; //теперь тупо добавляем изменения в html таймеру разных кнопок, что бы отображал время при помощи нашей переменной time
}

function decreaseTime() {
  if (time === 0) {
    finishGame();
  } else {
    let current = --time;

    if (current < 10) {
      current = `0${current}`;
    }

    timeEl.innerHTML = `00:${current}`;
  } // если время = 0, тогда игра будет остановлена, иначе будет все нижеперечисленное выполняться. НО теперь когда таймер будет на 0, игра будет замирать

  // let current = --time; //создаем переменную каррент (текущее время) и каждую секунду мы будем вычитать из общего времени игры (т.е. time).

  // if (current < 10) {
  //   current = `0${current}`;
  // } //теперь просто при помощи проверки делаем, отображение не 00:9, а 00:09, красивое отображение, если текущее время меньше десяти, тогда текущее время будет отображаться 0 + текущее время

  // timeEl.innerHTML = `00:${current}`; //и добавляем изменение html таймеру разных кнопок, что бы отображал в перменной time (шел назад каждую секунду)

  //ВРЕМЯ БУДЕТ ИДТИ В МИНУС, ДЕЛАЕМ ПРОВЕРКУ!
}

function finishGame() {
  timeEl.parentNode.remove(); //удаляем при окончании игры таймер (Если просто удалить timeEL уберется лишь только время, а слова остануться), нам нужно стереть и родителя тоже, для этого мы просто пишем timeEl.parentNode.

  board.innerHTML = `<h1>Cчет: <span class="primary">${score}</span></h1>`; //добавляем по окончанию игры в html надпись, Счет: и количество сделанных кликов по ходу игры!
}

function crateRandomCircle() {
  //создаем рандомное появление квадратов

  const circle = document.createElement("div"); // ВСЕГДА, что бы динамически создать любой HTML документ, мы будем обращаться к его функции createElement и в строковом формате, мы говорим, какой тег надо создать (В нашем случае - див )

  const color = randomColors(); //забираем рандомный цвет в переменную
  circle.style.background = color; //прописываем, что при клике мыши будет создаваться рандомный цвет

  circle.classList.add("circle"); //добавляем css стили к нашим будущим кружкам - аимам

  const size = getRandomNumber(10, 60); //даем диапазон по пикселям будущей рандомной ширине и высоте

  const { width, height } = board.getBoundingClientRect(); //спомощью специальной функции мы получаем действительную ширину и высоту нашего окна, в котором будут появл. квадратики!

  const x = getRandomNumber(0, width - size); //передаем в переменную случайную ширину с вычетом размеров (На всякий случай, что б точно влезало в окно)

  const y = getRandomNumber(0, height - size); //передаем в переменную  случайную высоту с вычетом размеров (На всякий случай, что б точно влезало в окно)

  circle.style.width = `${size}px`; //задаем рандомную ширину самого кружка
  circle.style.height = `${size}px`; //задаем рандомную высоту самого кружка

  circle.style.top = `${y}px`; //передаем функцию рандомного позиционирования по высоте НО В СТИЛЯХ ПРОПИШИ АБСОЛЮТ САМОМУ КРУЖКУ
  circle.style.left = `${x}px`; //передаем функцию рандомного позиционирования по ширине НО В СТИЛЯХ ПРОПИШИ АБСОЛЮТ САМОМУ КРУЖКУ

  board.append(circle); //добавляем переменной с пустым дивом нашу перменную с будущими кружочками и вызовем эту ф-цию (crateRandomCircle()), когда стартуем игру
}

function getRandomNumber(min, max) {
  //функция которая будет создавать кружки рандомной высоты и ширины

  return Math.round(Math.random() * (max - min) + min);
} //ретурн для возвращения данного числа, math.floor, для получение целого числа с округлением в меньшую сторону

function randomColors() {
  return colors[Math.floor(Math.random() * colors.length)];
} //делаем рандомные цвета, путем создания рандомного числа и при помощи св-ва ретурн мы будем возвращать его
